name: Continuous Monitoring - Fitness Functions

on:
  schedule:
    # Run every 30 minutes for continuous monitoring
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      alert_threshold:
        description: 'Alert threshold for availability score'
        required: false
        default: '70'
        type: string
      check_interval_minutes:
        description: 'Check interval in minutes'
        required: false
        default: '5'
        type: string

env:
  PYTHON_VERSION: '3.9'
  ALERT_THRESHOLD: ${{ github.event.inputs.alert_threshold || 70 }}

jobs:
  health-monitoring:
    name: üè• Health Monitoring
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üêç Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: üîß Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: üîç Run health check
      id: health-check
      run: |
        echo "üè• Running health check..."
        
        # Create monitoring directory
        mkdir -p monitoring-results
        
        # Run fitness functions
        python -c "
        from fitness_functions import fitness_functions
        import json
        import time
        from datetime import datetime
        
        print('Running health check...')
        result = fitness_functions.run_availability_tests()
        
        # Create health report
        health_report = {
            'timestamp': time.time(),
            'datetime': datetime.now().isoformat(),
            'overall_score': result.overall_score,
            'is_healthy': result.is_healthy,
            'critical_path_available': result.critical_path_available,
            'issues': result.issues,
            'services': {
                name: {
                    'is_healthy': health.is_healthy,
                    'response_time': health.response_time,
                    'error_message': health.error_message
                }
                for name, health in result.services.items()
            }
        }
        
        # Save report
        with open('monitoring-results/health_report.json', 'w') as f:
            json.dump(health_report, f, indent=2)
        
        # Set output variables
        print(f'::set-output name=score::{result.overall_score}')
        print(f'::set-output name=healthy::{str(result.is_healthy).lower()}')
        print(f'::set-output name=critical_path::{str(result.critical_path_available).lower()}')
        print(f'::set-output name=issues_count::{len(result.issues)}')
        
        print(f'Health check completed - Score: {result.overall_score}/100')
        "
        
    - name: üìä Generate monitoring report
      id: monitoring-report
      run: |
        echo "üìã Generating monitoring report..."
        
        if [ -f "monitoring-results/health_report.json" ]; then
          SCORE=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(data['overall_score'])")
          HEALTHY=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(data['is_healthy'])")
          CRITICAL_PATH=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(data['critical_path_available'])")
          ISSUES_COUNT=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(len(data['issues']))")
          
          echo "## üè• Health Monitoring Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Overall Score:** $SCORE/100" >> $GITHUB_STEP_SUMMARY
          echo "**System Health:** $([ "$HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Unhealthy")" >> $GITHUB_STEP_SUMMARY
          echo "**Critical Path:** $([ "$CRITICAL_PATH" = "true" ] && echo "‚úÖ Available" || echo "‚ùå Unavailable")" >> $GITHUB_STEP_SUMMARY
          echo "**Issues Found:** $ISSUES_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check against alert threshold
          if [ "$SCORE" -lt "$ALERT_THRESHOLD" ]; then
            echo "üö® **ALERT:** System score below threshold ($ALERT_THRESHOLD)" >> $GITHUB_STEP_SUMMARY
            echo "::set-output name=alert::true"
          else
            echo "‚úÖ System health is within acceptable range" >> $GITHUB_STEP_SUMMARY
            echo "::set-output name=alert::false"
          fi
          
          # Show service details
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          python -c "
          import json
          data = json.load(open('monitoring-results/health_report.json'))
          for service_name, service_data in data['services'].items():
              status = '‚úÖ' if service_data['is_healthy'] else '‚ùå'
              response_time = service_data['response_time']
              print(f'- {status} **{service_name}:** {response_time:.3f}s')
          " >> $GITHUB_STEP_SUMMARY
          
        fi
        
    - name: üìä Upload monitoring results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: monitoring-results-$(date +%Y%m%d-%H%M)
        path: monitoring-results/
        retention-days: 7
        
    - name: üö® Send alert on threshold breach
      if: steps.monitoring-report.outputs.alert == 'true'
      run: |
        echo "üö® ALERT: System health score (${{ steps.health-check.outputs.score }}) is below threshold (${{ env.ALERT_THRESHOLD }})"
        echo "Issues found: ${{ steps.health-check.outputs.issues_count }}"
        
        # Here you would typically send notifications via:
        # - Slack webhook
        # - Email
        # - PagerDuty
        # - Microsoft Teams
        # - Discord
        
        echo "Alert would be sent to configured notification channels"
        
    - name: üìà Update health metrics
      run: |
        echo "üìà Updating health metrics..."
        
        # Create metrics file for tracking over time
        if [ -f "monitoring-results/health_report.json" ]; then
          SCORE=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(data['overall_score'])")
          TIMESTAMP=$(python -c "import json; data=json.load(open('monitoring-results/health_report.json')); print(data['timestamp'])")
          
          # Append to metrics file
          echo "$TIMESTAMP,$SCORE" >> monitoring-results/health_metrics.csv
          
          echo "Metrics updated - Score: $SCORE at $(date)"
        fi
        
    - name: üéØ Performance trend analysis
      if: always()
      run: |
        echo "üìä Analyzing performance trends..."
        
        if [ -f "monitoring-results/health_metrics.csv" ]; then
          # Simple trend analysis
          python -c "
          import pandas as pd
          import numpy as np
          from datetime import datetime
          
          try:
              # Read metrics
              df = pd.read_csv('monitoring-results/health_metrics.csv', header=None, names=['timestamp', 'score'])
              df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
              
              # Calculate trends
              recent_scores = df.tail(10)['score'].values
              avg_score = np.mean(recent_scores)
              trend = 'improving' if len(recent_scores) > 1 and recent_scores[-1] > recent_scores[0] else 'declining'
              
              print(f'Recent average score: {avg_score:.1f}/100')
              print(f'Trend: {trend}')
              print(f'Data points: {len(df)}')
              
              # Save trend analysis
              trend_report = {
                  'timestamp': datetime.now().isoformat(),
                  'recent_average': float(avg_score),
                  'trend': trend,
                  'data_points': len(df),
                  'min_score': float(df['score'].min()),
                  'max_score': float(df['score'].max())
              }
              
              import json
              with open('monitoring-results/trend_analysis.json', 'w') as f:
                  json.dump(trend_report, f, indent=2)
                  
          except Exception as e:
              print(f'Trend analysis failed: {e}')
          "
        fi
        
    - name: ‚úÖ Success notification
      if: success() && steps.monitoring-report.outputs.alert == 'false'
      run: |
        echo "‚úÖ Health monitoring completed successfully"
        echo "System score: ${{ steps.health-check.outputs.score }}/100"
        echo "All systems operational"
        
    - name: ‚ö†Ô∏è Warning notification
      if: success() && steps.monitoring-report.outputs.alert == 'true'
      run: |
        echo "‚ö†Ô∏è Health monitoring completed with warnings"
        echo "System score: ${{ steps.health-check.outputs.score }}/100 (below threshold ${{ env.ALERT_THRESHOLD }})"
        echo "Issues detected: ${{ steps.health-check.outputs.issues_count }}" 